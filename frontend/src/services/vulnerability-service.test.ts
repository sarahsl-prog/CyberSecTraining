/**
 * Vulnerability service unit tests.
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { vulnerabilityService } from './vulnerability-service';
import {
  mockFetch,
  mockFetchError,
  mockVulnerability,
  mockVulnerabilities,
  mockVulnerabilitySummary,
} from '@/test/mocks';

describe('VulnerabilityService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('list', () => {
    it('should list vulnerabilities with pagination', async () => {
      const response = {
        items: mockVulnerabilities,
        total: 3,
        page: 1,
        page_size: 20,
        pages: 1,
      };
      mockFetch(response);

      const result = await vulnerabilityService.list({ page: 1, page_size: 20 });

      expect(global.fetch).toHaveBeenCalledTimes(1);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.items).toHaveLength(3);
      }
    });

    it('should filter by severity', async () => {
      const criticalVulns = mockVulnerabilities.filter(
        (v) => v.severity === 'critical'
      );
      mockFetch({
        items: criticalVulns,
        total: 1,
        page: 1,
        page_size: 20,
        pages: 1,
      });

      await vulnerabilityService.list({ severity: 'critical' });

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('severity=critical'),
        expect.any(Object)
      );
    });

    it('should filter by fix status', async () => {
      const unfixedVulns = mockVulnerabilities.filter((v) => !v.is_fixed);
      mockFetch({
        items: unfixedVulns,
        total: 2,
        page: 1,
        page_size: 20,
        pages: 1,
      });

      await vulnerabilityService.list({ is_fixed: false });

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('is_fixed=false'),
        expect.any(Object)
      );
    });
  });

  describe('get', () => {
    it('should fetch a single vulnerability', async () => {
      mockFetch(mockVulnerability);

      const result = await vulnerabilityService.get('vuln-1');

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/vulnerabilities/vuln-1'),
        expect.any(Object)
      );
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.id).toBe('vuln-1');
      }
    });

    it('should return error for non-existent vulnerability', async () => {
      mockFetchError('Vulnerability not found', 404);

      const result = await vulnerabilityService.get('non-existent');

      expect(result.success).toBe(false);
    });
  });

  describe('update', () => {
    it('should update vulnerability information', async () => {
      const updated = { ...mockVulnerability, title: 'Updated Title' };
      mockFetch(updated);

      const result = await vulnerabilityService.update('vuln-1', {
        title: 'Updated Title',
      });

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/vulnerabilities/vuln-1'),
        expect.objectContaining({
          method: 'PUT',
        })
      );
      expect(result.success).toBe(true);
    });
  });

  describe('markFixed', () => {
    it('should mark vulnerability as fixed', async () => {
      const fixed = {
        ...mockVulnerability,
        is_fixed: true,
        fixed_at: '2024-12-08T15:00:00Z',
      };
      mockFetch(fixed);

      const result = await vulnerabilityService.markFixed('vuln-1', {
        is_fixed: true,
        verified: false,
      });

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/vulnerabilities/vuln-1/mark-fixed'),
        expect.objectContaining({
          method: 'POST',
          body: JSON.stringify({ is_fixed: true, verified: false }),
        })
      );
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.is_fixed).toBe(true);
      }
    });
  });

  describe('getSummary', () => {
    it('should fetch vulnerability summary', async () => {
      mockFetch(mockVulnerabilitySummary);

      const result = await vulnerabilityService.getSummary();

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('/vulnerabilities/summary'),
        expect.any(Object)
      );
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.total).toBe(15);
        expect(result.data.critical).toBe(2);
        expect(result.data.high).toBe(5);
      }
    });
  });

  describe('getTypes', () => {
    it('should fetch vulnerability types', async () => {
      const types = ['default_credentials', 'open_telnet', 'unencrypted_http'];
      mockFetch(types);

      const result = await vulnerabilityService.getTypes();

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toContain('default_credentials');
      }
    });
  });

  describe('getBySeverity', () => {
    it('should fetch vulnerabilities by severity', async () => {
      const highVulns = mockVulnerabilities.filter((v) => v.severity === 'high');
      mockFetch({
        items: highVulns,
        total: 1,
        page: 1,
        page_size: 20,
        pages: 1,
      });

      await vulnerabilityService.getBySeverity('high');

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('severity=high'),
        expect.any(Object)
      );
    });
  });

  describe('getUnfixed', () => {
    it('should fetch only unfixed vulnerabilities', async () => {
      mockFetch({
        items: mockVulnerabilities.filter((v) => !v.is_fixed),
        total: 2,
        page: 1,
        page_size: 20,
        pages: 1,
      });

      await vulnerabilityService.getUnfixed();

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('is_fixed=false'),
        expect.any(Object)
      );
    });
  });

  describe('getCriticalAndHigh', () => {
    it('should fetch both critical and high vulnerabilities', async () => {
      // Mock two parallel requests
      mockFetch({
        items: mockVulnerabilities.filter((v) => v.severity === 'critical'),
        total: 1,
        page: 1,
        page_size: 20,
        pages: 1,
      });
      mockFetch({
        items: mockVulnerabilities.filter((v) => v.severity === 'high'),
        total: 1,
        page: 1,
        page_size: 20,
        pages: 1,
      });

      const result = await vulnerabilityService.getCriticalAndHigh();

      expect(global.fetch).toHaveBeenCalledTimes(2);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.critical).toBeDefined();
        expect(result.data.high).toBeDefined();
      }
    });
  });

  describe('count', () => {
    it('should return vulnerability count', async () => {
      mockFetch({
        items: [],
        total: 25,
        page: 1,
        page_size: 1,
        pages: 25,
      });

      const result = await vulnerabilityService.count();

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toBe(25);
      }
    });

    it('should count with filters', async () => {
      mockFetch({
        items: [],
        total: 5,
        page: 1,
        page_size: 1,
        pages: 5,
      });

      await vulnerabilityService.count({ severity: 'critical' });

      expect(global.fetch).toHaveBeenCalledWith(
        expect.stringContaining('severity=critical'),
        expect.any(Object)
      );
    });
  });
});
