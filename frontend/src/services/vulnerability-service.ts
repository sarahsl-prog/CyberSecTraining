/**
 * Vulnerability management service.
 *
 * Provides methods for vulnerability operations including:
 * - Listing and filtering vulnerabilities
 * - Getting vulnerability details
 * - Updating vulnerability information
 * - Marking vulnerabilities as fixed
 * - Getting summary statistics
 */

import type {
  Vulnerability,
  VulnerabilityUpdate,
  VulnerabilityMarkFixed,
  VulnerabilityListResponse,
  VulnerabilitySummary,
  VulnerabilityFilters,
  SeverityLevel,
} from '@/types';
import type { ApiResult, PaginationParams } from '@/types';
import { apiClient, type RequestConfig } from './api-client';
import { logger } from './logger';

const log = logger.create('VulnerabilityService');

/**
 * Combined vulnerability list options.
 */
export interface VulnerabilityListOptions extends VulnerabilityFilters, PaginationParams {}

/**
 * Vulnerability management service.
 *
 * Provides all vulnerability-related API operations.
 */
export const vulnerabilityService = {
  /**
   * List vulnerabilities with pagination and filtering.
   *
   * @param options - Filter and pagination options
   * @param config - Optional request configuration
   * @returns Paginated vulnerability list
   *
   * @example
   * ```ts
   * const result = await vulnerabilityService.list({
   *   severity: 'critical',
   *   is_fixed: false,
   *   page: 1,
   *   page_size: 20,
   * });
   * ```
   */
  async list(
    options?: VulnerabilityListOptions,
    config?: RequestConfig
  ): Promise<ApiResult<VulnerabilityListResponse>> {
    log.debug('Listing vulnerabilities', options);
    return apiClient.get<VulnerabilityListResponse>('/vulnerabilities', {
      ...config,
      params: options as Record<string, string | number | boolean | undefined>,
    });
  },

  /**
   * Get a single vulnerability by ID.
   *
   * @param vulnId - The vulnerability identifier
   * @param config - Optional request configuration
   * @returns Vulnerability details
   */
  async get(
    vulnId: string,
    config?: RequestConfig
  ): Promise<ApiResult<Vulnerability>> {
    log.debug('Fetching vulnerability', { vulnId });
    return apiClient.get<Vulnerability>(`/vulnerabilities/${vulnId}`, config);
  },

  /**
   * Update vulnerability information.
   *
   * Only the provided fields will be updated.
   *
   * @param vulnId - The vulnerability identifier
   * @param update - Fields to update
   * @param config - Optional request configuration
   * @returns Updated vulnerability
   */
  async update(
    vulnId: string,
    update: VulnerabilityUpdate,
    config?: RequestConfig
  ): Promise<ApiResult<Vulnerability>> {
    log.info('Updating vulnerability', { vulnId, update });
    return apiClient.put<Vulnerability>(`/vulnerabilities/${vulnId}`, update, config);
  },

  /**
   * Mark a vulnerability as fixed or unfixed.
   *
   * @param vulnId - The vulnerability identifier
   * @param status - Fix status
   * @param config - Optional request configuration
   * @returns Updated vulnerability
   */
  async markFixed(
    vulnId: string,
    status: VulnerabilityMarkFixed,
    config?: RequestConfig
  ): Promise<ApiResult<Vulnerability>> {
    log.info('Marking vulnerability fixed status', { vulnId, ...status });
    return apiClient.post<Vulnerability>(`/vulnerabilities/${vulnId}/mark-fixed`, status, config);
  },

  /**
   * Get vulnerability summary statistics.
   *
   * Returns counts grouped by severity and fix status.
   *
   * @param config - Optional request configuration
   * @returns Summary statistics
   */
  async getSummary(
    config?: RequestConfig
  ): Promise<ApiResult<VulnerabilitySummary>> {
    log.debug('Fetching vulnerability summary');
    return apiClient.get<VulnerabilitySummary>('/vulnerabilities/summary', config);
  },

  /**
   * Get list of available vulnerability types.
   *
   * @param config - Optional request configuration
   * @returns List of vulnerability type identifiers
   */
  async getTypes(
    config?: RequestConfig
  ): Promise<ApiResult<string[]>> {
    log.debug('Fetching vulnerability types');
    return apiClient.get<string[]>('/vulnerabilities/types/list', config);
  },

  /**
   * Get vulnerabilities by severity level.
   *
   * Convenience method for filtering by severity.
   *
   * @param severity - Severity level to filter
   * @param options - Additional filter options
   * @param config - Optional request configuration
   * @returns Paginated vulnerability list
   */
  async getBySeverity(
    severity: SeverityLevel,
    options?: Omit<VulnerabilityListOptions, 'severity'>,
    config?: RequestConfig
  ): Promise<ApiResult<VulnerabilityListResponse>> {
    return this.list({ ...options, severity }, config);
  },

  /**
   * Get unfixed vulnerabilities.
   *
   * Convenience method for finding active security issues.
   *
   * @param options - Additional filter options
   * @param config - Optional request configuration
   * @returns Paginated vulnerability list
   */
  async getUnfixed(
    options?: Omit<VulnerabilityListOptions, 'is_fixed'>,
    config?: RequestConfig
  ): Promise<ApiResult<VulnerabilityListResponse>> {
    return this.list({ ...options, is_fixed: false }, config);
  },

  /**
   * Get critical and high severity vulnerabilities.
   *
   * Useful for prioritizing remediation efforts.
   *
   * @param options - Additional filter options
   * @param config - Optional request configuration
   * @returns Object with critical and high vulnerabilities
   */
  async getCriticalAndHigh(
    options?: PaginationParams,
    config?: RequestConfig
  ): Promise<ApiResult<{
    critical: VulnerabilityListResponse;
    high: VulnerabilityListResponse;
  }>> {
    log.debug('Fetching critical and high vulnerabilities');

    const [criticalResult, highResult] = await Promise.all([
      this.list({ ...options, severity: 'critical', is_fixed: false }, config),
      this.list({ ...options, severity: 'high', is_fixed: false }, config),
    ]);

    if (!criticalResult.success) {
      return criticalResult;
    }
    if (!highResult.success) {
      return highResult;
    }

    return {
      success: true,
      data: {
        critical: criticalResult.data,
        high: highResult.data,
      },
    };
  },

  /**
   * Count vulnerabilities matching filters.
   *
   * Uses pagination metadata to get total count without fetching all data.
   *
   * @param filters - Filter options
   * @param config - Optional request configuration
   * @returns Total count
   */
  async count(
    filters?: VulnerabilityFilters,
    config?: RequestConfig
  ): Promise<ApiResult<number>> {
    const result = await this.list(
      { ...filters, page: 1, page_size: 1 },
      config
    );

    if (!result.success) {
      return result;
    }

    return { success: true, data: result.data.total };
  },
};
